<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>HashMap 部分源码阅读</title>
    <link href="/2021/07/19/HashMap-%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <url>/2021/07/19/HashMap-%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="默认值常量"><a href="#默认值常量" class="headerlink" title="默认值常量"></a>默认值常量</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 默认初始容量（16）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 最大容量（1,073,741,824）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 默认加载因子（0.75），超过当前长度超过容量的 0.75 就会扩容</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75f</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 树化阈值，当一个桶下的链表长度大于 8 时，就转化成红黑树</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TREEIFY_THRESHOLD = <span class="hljs-number">8</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 去树化阈值，当一个桶下的树的节点树小于 6 时，就会转化为链表</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> UNTREEIFY_THRESHOLD = <span class="hljs-number">6</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 最小树化阈值，当 HashMap 的大小大于该值时，才允许树化，否则，若桶内元素过多时，就直接扩容，而非树化</span><br><span class="hljs-comment"> * 这个值用于避免进行扩容和树化的选择冲突，这个值不能小于 4 倍的 树化阈值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="hljs-number">64</span>;<br></code></pre></div></td></tr></table></figure><h2 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 哈希表本质就是维护一个节点数组，节点的结构下面会提到</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 实体集合，用于遍历 Map</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * map 的大小，区别源码中的容量与大小，大小指元素的个数，容量值哈希表（数组）的长度</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> size;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 修改次数，用于发现是否存在并发修改，如果有，则可以快速失败，直接抛出 ConcurrentModificationException</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> modCount;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 扩容阈值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">int</span> threshold;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 加载因子，用于扩容</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> loadFactor;<br></code></pre></div></td></tr></table></figure><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * HashMap 构造方法</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> initialCapacity 初始容量</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> loadFactor 加载因子</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span> </span>&#123;<br>    <span class="hljs-comment">// 如果初始容量小于 0，直接抛出异常</span><br>    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal initial capacity: &quot;</span> +<br>                initialCapacity);<br>    <span class="hljs-comment">// 如果初始容量大于最大容量，则将容量设为最大容量</span><br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>        initialCapacity = MAXIMUM_CAPACITY;<br>    <span class="hljs-comment">// 如果加载因子小于等于 0 或者不是数值类型，直接抛出异常</span><br>    <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> +<br>                loadFactor);<br>    <span class="hljs-keyword">this</span>.loadFactor = loadFactor;<br>    <span class="hljs-comment">// 这里初始的容量放在了扩容阈值，之后会在 resize 方法处理</span><br>    <span class="hljs-keyword">this</span>.threshold = tableSizeFor(initialCapacity);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * HashMap 的构造方法，这个构造方法只有一个 初始容量 参数，里面调用的是上面的构造方法，默认加载因子作为第二个参数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> initialCapacity 初始容量</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;<br>    <span class="hljs-comment">// 默认使用 0.75 作为加载因子</span><br>    <span class="hljs-keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 这是个无参的构造方法，初始容量和加载因子均采用默认值，也许会疑惑为什么里面只给加载因子赋值，这个疑问会在 resize 方法中解释</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="hljs-comment">// all other fields defaulted</span><br>    <span class="hljs-comment">// 注：此时初始容量等于 0</span><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 这个构造函数传入的是另外一个 Map</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> m</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;<br>    putMapEntries(m, <span class="hljs-keyword">false</span>);    <span class="hljs-comment">// 将 m 中所有元素放进当前 HashMap 的方法</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基本 hash 桶节点，静态内部类</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;K&gt; 键</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;V&gt; 值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;         <span class="hljs-comment">// hsah 值</span><br>    <span class="hljs-keyword">final</span> K key;            <span class="hljs-comment">// 键</span><br>    V value;                <span class="hljs-comment">// 值</span><br>    Node&lt;K,V&gt; next;         <span class="hljs-comment">// 下一个节点</span><br><br>    Node(<span class="hljs-keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;<br>        <span class="hljs-keyword">this</span>.hash = hash;<br>        <span class="hljs-keyword">this</span>.key = key;<br>        <span class="hljs-keyword">this</span>.value = value;<br>        <span class="hljs-keyword">this</span>.next = next;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> K <span class="hljs-title">getKey</span><span class="hljs-params">()</span>        </span>&#123; <span class="hljs-keyword">return</span> key; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">getValue</span><span class="hljs-params">()</span>      </span>&#123; <span class="hljs-keyword">return</span> value; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> key + <span class="hljs-string">&quot;=&quot;</span> + value; &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 重写了 hashCode</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回 key 的直接地址和 异或 value 的直接地址的结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置新的 value ，返回旧的 value</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> newValue 新的 value</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 旧的 value</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">setValue</span><span class="hljs-params">(V newValue)</span> </span>&#123;<br>        V oldValue = value;<br>        value = newValue;<br>        <span class="hljs-keyword">return</span> oldValue;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 重写 equals 方法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> o 待比较的对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果直接地址相等，则相等</span><br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">this</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Map.Entry) &#123;   <span class="hljs-comment">// 比较的前提是待比较对象也是 Map.Entry 的实现类</span><br>            <span class="hljs-comment">// 先类型转换</span><br>            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;<br>            <span class="hljs-comment">// 如果它们的 key 和 value 都相等，就认为它们相等</span><br>            <span class="hljs-keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;<br>                    Objects.equals(value, e.getValue()))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 真正的 hash 函数，HashMap 采用的 hash 值并非普通的 hashCode 方法产生的，而是由 hashCode 方法产生的 hash 值，将高 16 位与低 16 位进行运算，产生真正的 hash 值，这样做的优点在于避免原来顺序相近的值 hash 后的位置也是相近的（哈希冲突机率很大）。将高位和低位的值一起运算能进一步打乱值得位置，增大 hash 后的随机性，降低哈希冲突的可能性</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> key 将要进行 hash 的键</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 得出的真正 hash 值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> h;      <span class="hljs-comment">// 键的 hashCode</span><br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);   <span class="hljs-comment">// 如果 key 不为空，则 hash 值为 key 的 hashCode 异或 key 的 hashCode 无符号右移 16 位的值</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h2><p>这个方法可以说是 HashMap 中非常核心的方法了。它将初始化和扩容的写在其中。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>        <span class="hljs-comment">// 旧表</span><br>        Node&lt;K,V&gt;[] oldTab = table;<br>        <span class="hljs-comment">// 旧容量</span><br>        <span class="hljs-keyword">int</span> oldCap = (oldTab == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>        <span class="hljs-comment">// 旧阈值</span><br>        <span class="hljs-keyword">int</span> oldThr = threshold;<br>        <span class="hljs-comment">// 新容量</span><br>        <span class="hljs-keyword">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 当旧容量不为 0 ，即旧表不为空，针对传入容量进行构造的情况</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 当旧容量超过最大容量</span><br>            <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>                <span class="hljs-comment">// 阈值设为最大 Integer ，意思是不会进行扩容了</span><br>                threshold = Integer.MAX_VALUE;<br>                <span class="hljs-comment">// 直接返回旧表</span><br>                <span class="hljs-keyword">return</span> oldTab;<br>            &#125;<br>            <span class="hljs-comment">// 将新容量设为旧容量的两倍</span><br>            <span class="hljs-comment">// 如果新容量仍小于最大容量，且旧容量大于等于默认初始容量</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>                <span class="hljs-comment">// 将新阈值设为旧阈值的两倍</span><br>                newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span><br>        &#125;<br>        <span class="hljs-comment">// 因为上面的构造方法中，将传入的容量放在了阈值中，所以这里才是真正的赋值到容量中</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span><br>            newCap = oldThr;<br>        <span class="hljs-comment">// 调用了无参构造的就执行这里，新容量和新阈值都赋默认值</span><br>        <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// zero initial threshold signifies using defaults</span><br>            newCap = DEFAULT_INITIAL_CAPACITY;<br>            newThr = (<span class="hljs-keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>        &#125;<br>        <span class="hljs-comment">// 这里是针对使用有参构造方法的初始化工作，与扩容的逻辑无关</span><br>        <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">float</span> ft = (<span class="hljs-keyword">float</span>)newCap * loadFactor;<br>            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY ?<br>                      (<span class="hljs-keyword">int</span>)ft : Integer.MAX_VALUE);<br>        &#125;<br>        <span class="hljs-comment">// 将新阈值赋值到成员变量中</span><br>        threshold = newThr;<br>        <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>        <span class="hljs-comment">// 核心步骤，创建一个新的哈希表</span><br>        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node[newCap];<br>        <span class="hljs-comment">// 将新表赋值到成员变量中</span><br>        table = newTab;<br>        <span class="hljs-comment">// 如果旧表不为空，就有元素迁移的操作；否则，直接返回新表，完成初始化操作</span><br>        <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 遍历旧表</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>                Node&lt;K,V&gt; e;<br>                <span class="hljs-comment">// 将当前头节点赋值给临时变量 e</span><br>                <span class="hljs-comment">// 如果 e 不为空</span><br>                <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">// 原来哈希表的位置置为空，方便 gc</span><br>                    oldTab[j] = <span class="hljs-keyword">null</span>;<br>                    <span class="hljs-comment">// 如果当前头节点没有后续节点</span><br>                    <span class="hljs-keyword">if</span> (e.next == <span class="hljs-keyword">null</span>)<br>                        <span class="hljs-comment">// 则直接重新哈希运算后放入新表的对应位置</span><br>                        newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;<br>                    <span class="hljs-comment">// 如果当前头节点是红黑树的头节点</span><br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)<br>                        <span class="hljs-comment">// 红黑树的重新哈希逻辑</span><br>                        ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-keyword">this</span>, newTab, j, oldCap);<br>                    <span class="hljs-comment">// 如果当前节点是普通链表的节点</span><br>                    <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// preserve order</span><br>                        <span class="hljs-comment">// 存储索引位置为：“原索引位置”的节点</span><br>                        Node&lt;K,V&gt; loHead = <span class="hljs-keyword">null</span>, loTail = <span class="hljs-keyword">null</span>;<br>                        <span class="hljs-comment">// 存储索引位置为：“原索引位置 + 旧容量”的节点</span><br>                        Node&lt;K,V&gt; hiHead = <span class="hljs-keyword">null</span>, hiTail = <span class="hljs-keyword">null</span>;<br>                        <span class="hljs-comment">// 临时节点，游标</span><br>                        Node&lt;K,V&gt; next;<br>                        <span class="hljs-keyword">do</span> &#123;<br>                            <span class="hljs-comment">// 游标指向当前节点的下一个元素</span><br>                            next = e.next;<br>                            <span class="hljs-comment">// 如果当前节点的哈希值与上旧容量等于 0 ，则扩容后的索引位置跟旧表的索引位置一样</span><br>                            <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                                <span class="hljs-comment">// 如果 loTail 为空，则当前节点为第一个节点</span><br>                                <span class="hljs-keyword">if</span> (loTail == <span class="hljs-keyword">null</span>)<br>                                    loHead = e;<br>                                <span class="hljs-comment">// 否则接到 loTail 的后面    </span><br>                                <span class="hljs-keyword">else</span><br>                                    loTail.next = e;<br>                                <span class="hljs-comment">// loTail 移到当前节点    </span><br>                                loTail = e;<br>                            &#125;<br>                            <span class="hljs-comment">// 如果当前节点的哈希值与上旧容量不等于 0，则扩容后的索引位置为 旧表的索引位置 + 旧容量</span><br>                            <span class="hljs-keyword">else</span> &#123;<br>                                <span class="hljs-comment">// 道理同上</span><br>                                <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-keyword">null</span>)<br>                                    hiHead = e;<br>                                <span class="hljs-keyword">else</span><br>                                    hiTail.next = e;<br>                                hiTail = e;<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-keyword">null</span>);   <span class="hljs-comment">// 当前节点移到游标处；如果当前节点不为空，继续循环</span><br>                        <span class="hljs-comment">// 如果 loTail 不为空，则说明当前索引位置有元素，且链表已经生成好了，那怕只有一个元素；</span><br>                        <span class="hljs-keyword">if</span> (loTail != <span class="hljs-keyword">null</span>) &#123;<br>                            <span class="hljs-comment">// 将链表最后一个元素的下一个元素置为空</span><br>                            loTail.next = <span class="hljs-keyword">null</span>;<br>                            <span class="hljs-comment">// 将链表的头节点放入当前索引位置，接上哈希表</span><br>                            newTab[j] = loHead;<br>                        &#125;<br>                        <span class="hljs-comment">// 道理同上</span><br>                        <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-keyword">null</span>) &#123;<br>                            hiTail.next = <span class="hljs-keyword">null</span>;<br>                            newTab[j + oldCap] = hiHead;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> newTab;<br>    &#125;<br></code></pre></div></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>这个过程可以分成两段来看，创建新表之前为确定哈希表的属性，其中将初始化时的逻辑和扩容时的逻辑揉在一起了，可能看起来比较吃力；创建新表之后，如果是当前为初始化过程，则直接返回新表；如果是扩容过程，则在遍历旧表的过程中分三种情况，一是当前位置只有一个节点，二是当前位置有一条链表，三是当前位置有一颗红黑树。<h3 id="问题：扩容后，节点重-hash-为什么只可能分布在-“原索引位置”-与-“原索引-oldCap-位置”-？"><a href="#问题：扩容后，节点重-hash-为什么只可能分布在-“原索引位置”-与-“原索引-oldCap-位置”-？" class="headerlink" title="问题：扩容后，节点重 hash 为什么只可能分布在 “原索引位置” 与 “原索引 + oldCap 位置” ？"></a>问题：扩容后，节点重 hash 为什么只可能分布在 “原索引位置” 与 “原索引 + oldCap 位置” ？</h3><img src="https://gitee.com/starryxcn/image-repo/raw/master/img/20210719115051.png"></li><li>决定元素原来索引位置的，是将元素的哈希值取模后得出的。以原容量 16 为例，如上图，哈希值取模就相当于将哈希值留下低（ （16 - 1）的位数）位，即低 4 位，扩容又是两倍两倍地扩，所以扩容后就是留下哈希值的低 5 位，如果原来的第 5 位为 0 则说明还是原来的位置，如果为 1 ，则说明在原来位置的基础上加上 10000（16）。</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://blog.csdn.net/v123411739/article/details/78996181/">史上最详细的 JDK 1.8 HashMap 源码解析_程序员囧辉-CSDN博客_hashmap1.8</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>源码阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java SE</tag>
      
      <tag>HashMap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring 之 漫谈IoC</title>
    <link href="/2021/03/18/Spring-%E4%B9%8B-%E6%BC%AB%E8%B0%88IOC/"/>
    <url>/2021/03/18/Spring-%E4%B9%8B-%E6%BC%AB%E8%B0%88IOC/</url>
    
    <content type="html"><![CDATA[<h1 id="IoC-和-DI"><a href="#IoC-和-DI" class="headerlink" title="IoC  和  DI"></a>IoC  和  DI</h1><p>​    IoC，Inversion of Control，即控制反转，是面向对象编程中的一种思想，或者说是一个程序设计中要达到的目的。</p><p>​    DI，Dependency Injection，即依赖注入，是实现 IoC 的一种方法，或者说是达到 IoC 这一目的的一个过程。</p><h1 id="IoC-的好处"><a href="#IoC-的好处" class="headerlink" title="IoC 的好处"></a>IoC 的好处</h1><p>​    举个例子，假如我们要设计一辆汽车：先设计轮子，然后根据轮子大小设计底盘，接着根据底盘设计车身，最后根据车身设计好整个汽车。这里就出现了一个“依赖”关系：汽车依赖车身，车身依赖底盘，底盘依赖轮子。</p><p><img src="https://pic4.zhimg.com/80/v2-c68248bb5d9b4d64d22600571e996446_1440w.jpg?source=1940ef5c"></p><p>​    根据上面的场景，我们用代码模拟出来的样子是这样的：</p><p><img src="https://pic4.zhimg.com/80/v2-8ec294de7d0f9013788e3fb5c76069ef_1440w.jpg?source=1940ef5c"></p><p>​    这个时候，突然要改变需求，要将轮子的大小改为可以动态定义的，这时代码应该改为：</p><p><img src="https://pic1.zhimg.com/80/v2-82e0c12a1b26f7979ed9241e169affda_1440w.jpg?source=1940ef5c"></p><p>这样一改，每个类都需要改变了，说明这种代码的组织方式不太合理，类与类之间的耦合性太高，可维护性太差了。</p><p>​    这就提出问题，怎样才能降低类之间的耦合性呢？答案就是让这条类的依赖链反过来，上图：</p><p><img src="https://pic3.zhimg.com/80/v2-e64bf72c5c04412f626b21753aa9e1a1_1440w.jpg?source=1940ef5c"></p><p>代码的修改如下：</p><p><img src="https://pic4.zhimg.com/80/v2-c920a0540ce0651003a5326f6ef9891d_1440w.jpg?source=1940ef5c"></p><p>这里我们再把轮胎大小变成可动态改变的，同样为了让整个系统顺利运行，我们需要做如下修改：</p><p><img src="https://pic1.zhimg.com/80/v2-99ad2cd809fcb86dd791ff7f65fb1779_1440w.jpg?source=1940ef5c"></p><p>​    <strong>这样一修改，将创建所依赖的类的控制权，由类本身转交到其他地方，所依赖的类不再由类自己创建，而是通过传参的方式，注入到类中。这就是依赖注入（DI），这样的代码组织方式就实现了控制反转（IoC）这一目的。如果从类之间关系的角度说，就是将原来的组合关系改造成聚合关系，进而降低类之间的耦合度，提高可维护性。</strong></p><p>​    其实这里已经简单实现了 IoC 。但仔细观察就会发现，每当要使用 Car 这个类，都要从 Tire 这个类开始创建，然后再一个个去注入，每次要用都要手动写这么一段代码。如果类的依赖链变长，人都写傻了。</p><p>​    这时，Spring 的 IoC 容器就出现了。它的作用就将依赖注入这一过程自动化，我们只需事先将所需要的类在配置文件中配置好，Spring 就会自动帮我们创建这些对象，我们用的时候就去里面取就行。Spring 的 IoC 容器本质就是一个 Bean 工厂（工厂模式），所以它的顶级接口就叫做 BeanFactory 。</p><hr><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://www.zhihu.com/question/23277575/answer/169698662">https://www.zhihu.com/question/23277575/answer/169698662</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>漫谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>IoC</tag>
      
      <tag>DI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker快速入门</title>
    <link href="/2021/03/04/Docker%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/2021/03/04/Docker%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker-的思想"><a href="#Docker-的思想" class="headerlink" title="Docker 的思想"></a>Docker 的思想</h1><blockquote><ol><li>集装箱：<ol><li>会将所有需要的内容放到不同的集装箱中，谁需要这些环境就直接拿到这个集装箱就可以了</li></ol></li><li>标准化：<ol><li>运输的标准化：Docker有一个码头，所有上传的集装箱都放在了这个码头上，当谁需要某一个环境，就直接指派大海豚去搬运这个集装箱就可以了。</li><li>命令的标准化：Docker提供了一系列的命令，帮助我们去获取集装箱等等操作。</li><li>提供了REST的API：衍生出了很多图形化界面，Rancher。</li></ol></li><li>隔离性：<ol><li>Docker在运行集装箱内的内容时，会在LInux的内核中，单独的开辟一片空间，这片空间不会影响到其他程序。</li></ol></li></ol></blockquote><blockquote><ul><li>注册中心（中心仓库）</li><li>镜像（相当于将已经配置好的软件环境打成一个包）</li><li>容器（运行起来的镜像）</li></ul></blockquote><h1 id="Docker-的基本操作"><a href="#Docker-的基本操作" class="headerlink" title="Docker 的基本操作"></a>Docker 的基本操作</h1><h2 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h2><ol><li><p>卸载旧版本的 Docker</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo yum remove docker \<br>                  docker-client \<br>                  docker-client-latest \<br>                  docker-common \<br>                  docker-latest \<br>                  docker-latest-logrotate \<br>                  docker-logrotate \<br>                  docker-engine<br></code></pre></div></td></tr></table></figure></li><li><p>安装依赖环境</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo yum install -y yum-utils<br><br><span class="hljs-comment"># 设置为 阿里云 的镜像</span><br>$ sudo yum-config-manager \<br>    --add-repo \<br>    http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<br></code></pre></div></td></tr></table></figure></li><li><p>安装 DOCKER ENGINE</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo yum install -y docker-ce docker-ce-cli containerd.io<br></code></pre></div></td></tr></table></figure></li><li><p>设置启动 Docker</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo systemctl start docker<br></code></pre></div></td></tr></table></figure></li><li><p>设置开机自启 Docker</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo systemctl <span class="hljs-built_in">enable</span> docker<br></code></pre></div></td></tr></table></figure></li><li><p>测试是否安装成功</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo docker run hello-world<br></code></pre></div></td></tr></table></figure><p>如果能自动拉取镜像，就说明安装成功，如果不成功，就从头再来一遍</p></li></ol><h2 id="卸载-Docker"><a href="#卸载-Docker" class="headerlink" title="卸载 Docker"></a>卸载 Docker</h2><ol><li><p>卸载 Docker Engine, CLI, 和 Containerd packages:</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo yum remove docker-ce docker-ce-cli containerd.io<br></code></pre></div></td></tr></table></figure></li><li><p>镜像，容器，数据卷 和 自定义配置文件不会自动删除，所以要自行删除</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo rm -rf /var/lib/docker<br></code></pre></div></td></tr></table></figure></li></ol><h2 id="Docker-的中央仓库"><a href="#Docker-的中央仓库" class="headerlink" title="Docker 的中央仓库"></a>Docker 的中央仓库</h2><ol><li><p>Docker官方的中央仓库：这个仓库是镜像最全的，但是下载速度很慢。</p><ul><li><a href="https://hub.docker.com/">https://hub.docker.com</a></li></ul></li><li><p>国内的镜像网站：网易蜂巢、daoCloud…</p><ul><li><a href="https://c.163yun.com/hub#/home">https://c.163yun.com/hub#/home</a></li><li><a href="http://hub.daocloud.io/">http://hub.daocloud.io</a> (推荐使用)</li></ul></li><li><p>在公司内部会采用私服的方式拉取镜像。（添加配置）</p><figure class="highlight vala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vala"><span class="hljs-meta"># 需要在/etc/docker/daemon.json</span><br>&#123;<br><span class="hljs-string">&quot;registry-mirrors&quot;</span>:[<span class="hljs-string">&quot;https://registry.docker-cn.com&quot;</span>],<br>    <span class="hljs-string">&quot;insecure-registries&quot;</span>:[<span class="hljs-string">&quot;ip:port&quot;</span>]<br>&#125;<br><br><span class="hljs-meta"># 重启两个服务</span><br>systemctl daemon-reload<br>systemctl restart docker<br></code></pre></div></td></tr></table></figure></li></ol><h2 id="镜像的操作"><a href="#镜像的操作" class="headerlink" title="镜像的操作"></a>镜像的操作</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 拉取镜像到本地</span><br>docker pull 镜像名称[:tag]<br><span class="hljs-comment"># 举个例子</span><br>docker pull daocloud.io/library/tomcat:8.5.15-jre8<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 查看全部本地的镜像</span><br>docker images<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 删除本地镜像</span><br>docker rmi 镜像的标识<br><span class="hljs-comment"># rmi = remove image</span><br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 镜像的导入导出（不规范）</span><br><br><span class="hljs-comment"># 将本地的镜像导出</span><br>docker save -o 导出的路径 镜像id<br><br><span class="hljs-comment"># 加载本地的镜像文件</span><br>docker load -i 镜像文件<br><br><span class="hljs-comment"># 在加载本地的镜像文件后，镜像的名称 和 tag 都是 &lt;none&gt;</span><br><span class="hljs-comment"># 修改镜像名称</span><br>docker tag 镜像id 新镜像名称:版本<br><br><span class="hljs-comment"># 删除 同镜像ID 的镜像名称</span><br>docker rmi 镜像名称:版本<br></code></pre></div></td></tr></table></figure><h2 id="容器的操作"><a href="#容器的操作" class="headerlink" title="容器的操作"></a>容器的操作</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 1. 运行容器</span><br><span class="hljs-comment"># 简单操作</span><br>docker run 镜像的标识|镜像名称[:tag]<br><br><span class="hljs-comment"># 常用的参数</span><br>docker run -d -p 宿主机端口:容器端口 --name 容器名称 镜像的标识|镜像名称[:tag]<br><br><span class="hljs-comment"># -d：代表后台运行容器</span><br><span class="hljs-comment"># -p 宿主机端口:容器端口：为了映射当前Linux端口和容器端口</span><br><span class="hljs-comment"># --name 容器名称：指定容器的名称</span><br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 2. 查看正在运行的容器，默认只能看到当前正在运行的容器</span><br>docker ps [-qa]<br><br><span class="hljs-comment"># -a：查看全部的容器，包括没有运行</span><br><span class="hljs-comment"># -q：只查看容器得到标识</span><br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 3. 查看容器的日志</span><br>docker logs -f 容器id<br><span class="hljs-comment"># -f：可以滚动查看日志的最后几行</span><br><span class="hljs-comment"># 按 ctrl + c 退出</span><br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 4. 进入到容器内部</span><br>docker <span class="hljs-built_in">exec</span> -it 容器id bash<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 5. 删除容器（删除容器前，需要停止容器）</span><br><br><span class="hljs-comment"># 停止指定的容器</span><br>docker stop 容器id<br><br><span class="hljs-comment"># 停止全部容器</span><br>docker stop $(docker pa -qa)<br><br><span class="hljs-comment"># 删除指定的容器</span><br>docker rm 容器id<br><br><span class="hljs-comment"># 删除全部容器</span><br>docker rm $(docker pa -qa)<br><br><span class="hljs-comment"># $(...) 类似管道符号，将里面的返回值传给前面</span><br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 6. 启动容器</span><br>docker start 容器id<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>快速入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
