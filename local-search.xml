<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Spring 之 漫谈IOC</title>
    <link href="/2021/03/18/Spring-%E4%B9%8B-%E6%BC%AB%E8%B0%88IOC/"/>
    <url>/2021/03/18/Spring-%E4%B9%8B-%E6%BC%AB%E8%B0%88IOC/</url>
    
    <content type="html"><![CDATA[<h1 id="IOC-和-DI"><a href="#IOC-和-DI" class="headerlink" title="IOC  和  DI"></a>IOC  和  DI</h1><p>​    IOC，Inversion of Control，即控制反转，是面向对象编程中的一种思想，或者说是一个程序设计中要达到的目的。</p><p>​    DI，Dependency Injection，即依赖注入，是实现 IOC 的一种方法，或者说是达到 IOC 这一目的的一个过程。</p><h1 id="IOC-的好处"><a href="#IOC-的好处" class="headerlink" title="IOC 的好处"></a>IOC 的好处</h1><p>​    举个例子，假如我们要设计一辆汽车：先设计轮子，然后根据轮子大小设计底盘，接着根据底盘设计车身，最后根据车身设计好整个汽车。这里就出现了一个“依赖”关系：汽车依赖车身，车身依赖底盘，底盘依赖轮子。</p><p><img src="https://pic4.zhimg.com/80/v2-c68248bb5d9b4d64d22600571e996446_1440w.jpg?source=1940ef5c"></p><p>​    根据上面的场景，我们用代码模拟出来的样子是这样的：</p><p><img src="https://pic4.zhimg.com/80/v2-8ec294de7d0f9013788e3fb5c76069ef_1440w.jpg?source=1940ef5c"></p><p>​    这个时候，突然要改变需求，要将轮子的大小改为可以动态定义的，这时代码应该改为：</p><p><img src="https://pic1.zhimg.com/80/v2-82e0c12a1b26f7979ed9241e169affda_1440w.jpg?source=1940ef5c"></p><p>这样一改，每个类都需要改变了，说明这种代码的组织方式不太合理，类与类之间的耦合性太高，可维护性太差了。</p><p>​    这就提出问题，怎样才能降低类之间的耦合性呢？答案就是让这条类的依赖链反过来，上图：</p><p><img src="https://pic3.zhimg.com/80/v2-e64bf72c5c04412f626b21753aa9e1a1_1440w.jpg?source=1940ef5c"></p><p>代码的修改如下：</p><p><img src="https://pic4.zhimg.com/80/v2-c920a0540ce0651003a5326f6ef9891d_1440w.jpg?source=1940ef5c"></p><p>这里我们再把轮胎大小变成可动态改变的，同样为了让整个系统顺利运行，我们需要做如下修改：</p><p><img src="https://pic1.zhimg.com/80/v2-99ad2cd809fcb86dd791ff7f65fb1779_1440w.jpg?source=1940ef5c"></p><p>​    <strong>这样一修改，将创建所依赖的类的控制权，由类本身转交到其他地方，所依赖的类不再由类自己创建，而是通过传参的方式，注入到类中。这就是依赖注入（DI），这样的代码组织方式就实现了控制反转（IOC）这一目的。如果从类之间关系关系的角度说，就是将原来的组合关系改造成聚合关系，进而降低类之间的耦合度，提高可维护性。</strong></p><p>​    其实这里已经简单实现了 IOC 。但仔细观察就会发现，每当要使用 Car 这个类，都要从 Tire 这个类开始创建，然后再一个个去注入，每次要用都要手动写这么一段代码。如果类的依赖链变长，人都写傻了。</p><p>​    这时，Spring 的 IOC 容器就出现了。它的作用就将依赖注入这一过程自动化，我们只需事先将所需要的类在配置文件中配置好，Spring 就会自动帮我们创建这些对象，我们用的时候就去里面取就行。Spring 的 IOC 容器本质就是一个 Bean 工厂（工厂模式），所以它的顶级接口就叫做 BeanFactory 。</p><hr><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://www.zhihu.com/question/23277575/answer/169698662">https://www.zhihu.com/question/23277575/answer/169698662</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>漫谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>IOC</tag>
      
      <tag>DI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker快速入门</title>
    <link href="/2021/03/04/Docker%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/2021/03/04/Docker%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker-的思想"><a href="#Docker-的思想" class="headerlink" title="Docker 的思想"></a>Docker 的思想</h1><blockquote><ol><li>集装箱：<ol><li>会将所有需要的内容放到不同的集装箱中，谁需要这些环境就直接拿到这个集装箱就可以了</li></ol></li><li>标准化：<ol><li>运输的标准化：Docker有一个码头，所有上传的集装箱都放在了这个码头上，当谁需要某一个环境，就直接指派大海豚去搬运这个集装箱就可以了。</li><li>命令的标准化：Docker提供了一系列的命令，帮助我们去获取集装箱等等操作。</li><li>提供了REST的API：衍生出了很多图形化界面，Rancher。</li></ol></li><li>隔离性：<ol><li>Docker在运行集装箱内的内容时，会在LInux的内核中，单独的开辟一片空间，这片空间不会影响到其他程序。</li></ol></li></ol></blockquote><blockquote><ul><li>注册中心（中心仓库）</li><li>镜像（相当于将已经配置好的软件环境打成一个包）</li><li>容器（运行起来的镜像）</li></ul></blockquote><h1 id="Docker-的基本操作"><a href="#Docker-的基本操作" class="headerlink" title="Docker 的基本操作"></a>Docker 的基本操作</h1><h2 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h2><ol><li><p>卸载旧版本的 Docker</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo yum remove docker \<br>                  docker-client \<br>                  docker-client-latest \<br>                  docker-common \<br>                  docker-latest \<br>                  docker-latest-logrotate \<br>                  docker-logrotate \<br>                  docker-engine<br></code></pre></div></td></tr></table></figure></li><li><p>安装依赖环境</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo yum install -y yum-utils<br><br><span class="hljs-comment"># 设置为 阿里云 的镜像</span><br>$ sudo yum-config-manager \<br>    --add-repo \<br>    http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<br></code></pre></div></td></tr></table></figure></li><li><p>安装 DOCKER ENGINE</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo yum install -y docker-ce docker-ce-cli containerd.io<br></code></pre></div></td></tr></table></figure></li><li><p>设置启动 Docker</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo systemctl start docker<br></code></pre></div></td></tr></table></figure></li><li><p>设置开机自启 Docker</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo systemctl <span class="hljs-built_in">enable</span> docker<br></code></pre></div></td></tr></table></figure></li><li><p>测试是否安装成功</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo docker run hello-world<br></code></pre></div></td></tr></table></figure><p>如果能自动拉取镜像，就说明安装成功，如果不成功，就从头再来一遍</p></li></ol><h2 id="卸载-Docker"><a href="#卸载-Docker" class="headerlink" title="卸载 Docker"></a>卸载 Docker</h2><ol><li><p>卸载 Docker Engine, CLI, 和 Containerd packages:</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo yum remove docker-ce docker-ce-cli containerd.io<br></code></pre></div></td></tr></table></figure></li><li><p>镜像，容器，数据卷 和 自定义配置文件不会自动删除，所以要自行删除</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo rm -rf /var/lib/docker<br></code></pre></div></td></tr></table></figure></li></ol><h2 id="Docker-的中央仓库"><a href="#Docker-的中央仓库" class="headerlink" title="Docker 的中央仓库"></a>Docker 的中央仓库</h2><ol><li><p>Docker官方的中央仓库：这个仓库是镜像最全的，但是下载速度很慢。</p><ul><li><a href="https://hub.docker.com/">https://hub.docker.com</a></li></ul></li><li><p>国内的镜像网站：网易蜂巢、daoCloud…</p><ul><li><a href="https://c.163yun.com/hub#/home">https://c.163yun.com/hub#/home</a></li><li><a href="http://hub.daocloud.io/">http://hub.daocloud.io</a> (推荐使用)</li></ul></li><li><p>在公司内部会采用私服的方式拉取镜像。（添加配置）</p><figure class="highlight vala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vala"><span class="hljs-meta"># 需要在/etc/docker/daemon.json</span><br>&#123;<br><span class="hljs-string">&quot;registry-mirrors&quot;</span>:[<span class="hljs-string">&quot;https://registry.docker-cn.com&quot;</span>],<br>    <span class="hljs-string">&quot;insecure-registries&quot;</span>:[<span class="hljs-string">&quot;ip:port&quot;</span>]<br>&#125;<br><br><span class="hljs-meta"># 重启两个服务</span><br>systemctl daemon-reload<br>systemctl restart docker<br></code></pre></div></td></tr></table></figure></li></ol><h2 id="镜像的操作"><a href="#镜像的操作" class="headerlink" title="镜像的操作"></a>镜像的操作</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 拉取镜像到本地</span><br>docker pull 镜像名称[:tag]<br><span class="hljs-comment"># 举个例子</span><br>docker pull daocloud.io/library/tomcat:8.5.15-jre8<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 查看全部本地的镜像</span><br>docker images<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 删除本地镜像</span><br>docker rmi 镜像的标识<br><span class="hljs-comment"># rmi = remove image</span><br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 镜像的导入导出（不规范）</span><br><br><span class="hljs-comment"># 将本地的镜像导出</span><br>docker save -o 导出的路径 镜像id<br><br><span class="hljs-comment"># 加载本地的镜像文件</span><br>docker load -i 镜像文件<br><br><span class="hljs-comment"># 在加载本地的镜像文件后，镜像的名称 和 tag 都是 &lt;none&gt;</span><br><span class="hljs-comment"># 修改镜像名称</span><br>docker tag 镜像id 新镜像名称:版本<br><br><span class="hljs-comment"># 删除 同镜像ID 的镜像名称</span><br>docker rmi 镜像名称:版本<br></code></pre></div></td></tr></table></figure><h2 id="容器的操作"><a href="#容器的操作" class="headerlink" title="容器的操作"></a>容器的操作</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 1. 运行容器</span><br><span class="hljs-comment"># 简单操作</span><br>docker run 镜像的标识|镜像名称[:tag]<br><br><span class="hljs-comment"># 常用的参数</span><br>docker run -d -p 宿主机端口:容器端口 --name 容器名称 镜像的标识|镜像名称[:tag]<br><br><span class="hljs-comment"># -d：代表后台运行容器</span><br><span class="hljs-comment"># -p 宿主机端口:容器端口：为了映射当前Linux端口和容器端口</span><br><span class="hljs-comment"># --name 容器名称：指定容器的名称</span><br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 2. 查看正在运行的容器，默认只能看到当前正在运行的容器</span><br>docker ps [-qa]<br><br><span class="hljs-comment"># -a：查看全部的容器，包括没有运行</span><br><span class="hljs-comment"># -q：只查看容器得到标识</span><br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 3. 查看容器的日志</span><br>docker logs -f 容器id<br><span class="hljs-comment"># -f：可以滚动查看日志的最后几行</span><br><span class="hljs-comment"># 按 ctrl + c 退出</span><br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 4. 进入到容器内部</span><br>docker <span class="hljs-built_in">exec</span> -it 容器id bash<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 5. 删除容器（删除容器前，需要停止容器）</span><br><br><span class="hljs-comment"># 停止指定的容器</span><br>docker stop 容器id<br><br><span class="hljs-comment"># 停止全部容器</span><br>docker stop $(docker pa -qa)<br><br><span class="hljs-comment"># 删除指定的容器</span><br>docker rm 容器id<br><br><span class="hljs-comment"># 删除全部容器</span><br>docker rm $(docker pa -qa)<br><br><span class="hljs-comment"># $(...) 类似管道符号，将里面的返回值传给前面</span><br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 6. 启动容器</span><br>docker start 容器id<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>快速入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
